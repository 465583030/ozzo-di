# ozzo-di

[![GoDoc](https://godoc.org/github.com/go-ozzo/ozzo-di?status.png)](http://godoc.org/github.com/go-ozzo/ozzo-di)
[![Build Status](https://travis-ci.org/go-ozzo/ozzo-di.svg?branch=master)](https://travis-ci.org/go-ozzo/ozzo-di)
[![Coverage](http://gocover.io/_badge/github.com/go-ozzo/ozzo-di)](http://gocover.io/github.com/go-ozzo/ozzo-di)

ozzo-di это контейнер внедрения зависимостей (DI) на языке Go. Он имеет следующие возможности:

* DI через конкретные типы, интерфейсы, и функции провайдеры
* DI через значения параметров функций и поля структуры
* Создание и внедрение новых объектов
* Иерархические контейнеры DI

## Требования

Go 1.2 или выше.

## Установка

Выполните следующие команды для установки:

```
go get github.com/go-ozzo/ozzo-di
```

## С чего начать

Следующий фрагмент кода показывает, как можно использовать DI контейнер.

```go
package main

import (
	"fmt"
	"reflect"
	"github.com/go-ozzo/ozzo-di"
)

type Bar interface {
    String() string
}

func test(bar Bar) {
    fmt.Println(bar.String())
}

type Foo struct {
    s string
}

func (f *Foo) String() string {
    return f.s
}

type MyBar struct {
    Bar `inject`
}

func main() {
    // создаем DI контейнер
	c := di.NewContainer()

    // регистрируем экземпляр Foo как интерфейс типа Bar
    c.RegisterAs(&Foo{"hello"}, di.InterfaceOf((*Bar)(nil)))

    // &Foo{"hello"} будет внедрено как параметр Bar для test()
    c.Call(test)
    // Выведет:
    // hello

    // создаем объект MyBar и внедряем его в поле Bar
    bar := c.Make(reflect.TypeOf(&MyBar{})).(Bar)
    fmt.Println(bar.String())
    // Выведет:
    // hello
}
```


## Регистрация типа

`di.Container` это DI контейнер основанный на типах, чтобы определить какие значения нужно использовать для инекции. 
Для того, чтобы это произошло, вы, как правило, должны использовать типы, которые необходимы в поддержке DI.
`di.Container` поддерживает три вида регистрации типа, как показано в следующем фрагменте кода:

```go
c := di.NewContainer()

// 1. регистрация конкретного типа:

// &Foo{"hello"} зарегистрирован в качестве соответствующего конкретного типа (*Foo)
c.Register(&Foo{"hello"})


// 2. зарегистрирован как интерфейс:

// &Foo{"hello"} зарегистрирован какинтерфейс Bar
c.RegisterAs(&Foo{"hello"}, di.InterfaceOf((*Bar)(nil)))
// конкретный тип (*Foo) зарегистрирован как интерфейс Bar
c.RegisterAs(reflect.TypeOf(&Foo{}), di.InterfaceOf((*Bar)(nil)))


// 3. зарегистрирован как провайдер:

// функция-провайдер зарегистрирована как Bar интерфейс.
// Функция поставщик будет вызываться, когда внедряется Bar.
c.RegisterProvider(func(di.Container) interface{} {
    return &Foo{"hello"}
}, di.InterfaceOf((*Bar)(nil)), true)
```

> Совет: Чтобы указать тип интерфейса при регистрации, используйте функцию-помощник
> `di.InterfaceOf((*InterfaceName)(nil))`.
> Для конкретных типов, используйте Go функцию отображения `reflect.TypeOf(TypeName{})`.


## Внедрения значений

`di.Container` поддерживает три типа инъекции значений, как показано в следующем фрагменте кода:

```go
// ...продолжение предыдущего примера регистрации...

type Composite struct {
    Bar `inject`
}

// 1. внедрение поля структуры:

// Экспортированное поле структуры с тегом `inject` и анонимные поля будут внедрены со значениями.
// Здесь Composite.Bar будет внедрено со значением &Foo{"hello"}
composite := &Composite{}
c.Inject(composite)


// 2. внедрение параметра функции:

// Параметры функции будут внедрены со значениями в соответствии с их типами.
// Здесь bar будет внедрена со значением &Foo{"hello"}
func test(bar Bar) {
    fmt.Println(bar.String())
}
c.Call(test)


// 3. создания новых экземпляров:
// Новый экземпляр структуры может быть создан с внедрением ее полей.
// Или может быть возвращен синглтон-экземпляр.

foo := c.Make(reflect.TypeOf(&Foo{})).(*Foo)          // возвращает синглтон &Foo{"hello"}
bar := c.Make(di.InterfaceOf((*Bar)(nil))).(*Bar)     // возвращает синглтон &Foo{"hello"}

// Возвращает новый экземпляр Composite с внедреным в Bar синглтоном &Foo{"hello"}
composite := c.Make(reflect.TypeOf(&Composite{})).(*Composite)
```

при инъекции заранее зарегистрированного типа, если значение уже зарегистрировано как этот тип, само значение
будет использоваться для инъекции.

Если провайдер зарегистрирован в качестве типа, провайдер будет вызываться и его результат будет использован для внедрения.
При регистрации поставщика, вы можете использовать третий параметр для `Container.RegisterProvider()`, чтобы указать,
должен ли будет провайдер вызываться каждый раз, когда необходимо внедрение или только в первый раз. Если в последствии, 
поставщик будет вызван только один раз и один и тот же самый возващенный результат будет использован для внедрения в соответствии 
с зарегистрированным типом.

При внедрении значения типа `T` который не зарегистрирован, будет использована следующая стратегия:

* Если `*T` был зарегистрирован,  то соответствующее значение будет разыменовано и возвращено;
* Если `T` является указателем на `P`, указатель на значение внедренного для `P` будет возващен;
* Если тип `T` это структура, новый экземпляр будет создан и его поля будут внедрены;
* Если `T` это срез, карта, или канал, новый экземпляр будет создан и инициализирован;
* Во всех остальных случаях, будет возвращено нулевое значение.


## Признательность

ozzo-di ссылается на реализацию [codegansta/inject](https://github.com/codegangsta/inject/).
